---
title: 集群
project: riak
version: 1.4.2+
document: appendix
audience: intermediate
keywords: [appendix, concepts]
---

Riak 的相关操作默认在“集群”范围内进行。Riak 集群一般运行在相互连接的一群物理主机上，其中每个主机上都运行着一个 Riak 节点。每个 Riak 节点中又运行着一系列虚拟节点（简称 vnode），各虚拟节点负责存储键空间的不同分区。

节点直接不是相互克隆的，而且也不会全部回响每一个请求。要为哪些数据创建副本、什么时候进行合并、采用何种合并策略，以及失效模式等都在运行时设定。

## 环

本节的大部分内容都在讨论 Dynamo，但却很好地总结了 Riak 是如何实现各项必备功能的。

Riak 的客户端接口向外暴漏的是 [[buckets|Bucket]] 和[[键|键和对象]]。在内部，Riak 会计算“bucket/键”组合的 160 位二进制哈希值，然后映射到按序排列的环上的某个位置。环被分成多个分区，每个 Riak 虚拟节点负责一个分区。

Riak 集群中的各节点会试图运行相同数量的虚拟节点。一般情况下，这就意味着集群中的各节点会负责整个环的 1/（节点总数），或者（分区总数）/（节点总数）个虚拟节点。例如，如果一个集群中有两个节点，分成 16 个分区，那么每个节点就要运行 8 个虚拟节点。节点每隔一段时间就会声明各自负责环的哪个分区，这样各节点之间的数据就会均匀分布，而且不会出现一个节点储存同一个键的多个副本的情况。

值存入集群后，任何节点都可能称为某次请求的协调员。协调的节点会请求环的状态，查看哪个虚拟节点中包含被请求的值所在的分区，然后向这个虚拟节点及环中后续的 N-1 个分区所在的虚拟节点发起 PUT 请求，虚拟节点会回响，其中 N 是可以在每个 bucket 中设置的参数，指定存储的副本数量。PUT 请求还可以指定响应成功至少要有 W（=< N）个虚拟节点应答；如果已经持久化存储，响应成功至少需要 DW（=< W)）个应答。

读取请求类似，向包含键所在分区的虚拟节点即后续的 N-1 个分区所在的虚拟节点发起请求。请求时可以指定 R 值（=< N），指定在返回响应之前要有多少个虚拟节点做出应答。

## 广播

环的状态通过“广播协议”传布到整个集群中。每次节点负责的分区发生变化，都会通过这个协议发出广播。同时，这个协议还会定期重新宣布所了解的环状态，防止有节点漏接了前面的广播。

---
title: Why Riak
project: riak
version: 1.4.2+
document: tutorial
audience: beginner
keywords: [tutorial, fast-track]
versions: false
interest: [
"[[Clusters]]",
"[[Buckets]]",
"[[Eventual Consistency]]",
"[[Vector Clocks]]",
"[[Replication]]"
]
---

## Riak 是什么？

Riak 是一种分布式数据库，其设计目的是保持最大限度的可用性，只要客户端可以访问服务器，就能写入数据。如果失败了，大多数情况下数据还是可读的，只不过读出的数据可能过时了。

高度可用性的代价是可能过期的数据，这种妥协是 Riak 的关键架构方案。这种方案称为“最终一致性”，在分布式系统中很常见，比较著名的例子有 DNS 和 Web 缓存。

### Basho 对 Riak 设定的目标

目标 | 说明
-------|-------
**可用性** | Rial 在多个服务器上进行读写操作，即使出现硬件或网络问题，也能保证数据库的可用性
**操作便利性** | 在 Riak 集群中添加新设备的过程很简单，无需繁杂地操作
**可扩放性** | Riak 能在集群中自动分发数据，并能随着数据量的增加提升近线性的性能
**Masterless** | 对数据库的访问不会绑定到集群中特定的服务器上，避免单个服务器宕机造成无法访问

### 适合使用 Riak 的场景

如果把数据放在单台服务器中无法满足要求，请考虑使用 Riak 吧。分布式数据库是一个老大难问题，不是任何人都能处理地这么好。

Riak 十分看重可用性，如果你无法接受宕机，Riak 就是个很好地选择。没人能保证 100% 在线，不过在设计 Riak 时就考虑到了如何避免因网络隔断和硬件失效导致无法访问数据库，这两个问题是中断大多数数据库服务的罪魁祸首。

Riak 一个很少提及的特性是可预知的延迟。因为对 Riak 的基本操作（读，写，删除）不涉及复杂地数据连接和锁定，处理起来速度很快。其他数据管理软件就是看中了这一点，经常使用 Riak 储存数据。

### 不太适合使用 Riak 的场景

Basho 建议一个集群至少要有 5 台服务器，如果是小型数据库，使用 Riak 就大材小用了。如果你不知道是否需要分布式数据库，或许就不需要使用 Riak。

（虽然这么说，不过如果数据成爆炸式增长，还是建议提前为使用分布式数据库做好准备。网络中的扩放就像飞机飞行途中的检修一样，追求的是速度。）

Riak 的数据模型很简单，基于键值对，这意味着要想保证性能，就要对数据做反正规化处理。大多数应用程序都能反正规化数据，一旦数据无法高效的使用键值对处理，可能就说明此时不太适合使用 Riak。

附加说明：Riak 虽然提供了多种方法查询符合条件的值，但如果你的应用程序需要做大量不通过键的查询，Riak 就不如其他数据库高效。Basho 提供了一个工具，名为 **basho_bench**，可以用来测试性能，通过测试结果你可以衡量 Riak 提供的高可用性和操作便利性是否盖过了它的弱势。

## Riak 集群是如何工作的？

### 什么是 Riak 节点？

Riak 节点和服务器并不完全是一回事，不过在生产环境中二者是等价的。开发者可以在一个笔记本电脑中运行多个节点，但在实际的集群中并不推荐这么做。

Riak 集群中的每个节点的地位相同，都包含完整，而且独立的 Riak 包，因此没有“主节点”的概念，各节点的作用完全一样。节点的一致性是 Riak 容错和扩放的基础。

各节点都会负责多个数据分区，详情如下。

### 性能扩充后 Riak 会自动重新分发数据

增加或减少设备后，无需停机，数据会自动进行负载平衡操作。新添加的设备只到拥有权完全传遍整个集群后才能认领数据，融入集群后，集群的最新状态会经由 Gossip 协议通知每个节点，此时新设备才能用来分发请求。这么做可以保证集群中的任何节点都能处理请求，开发者无需叨扰存储数据的底层结构。

### 一致性哈希

数据在节点之间的分发是通过一致性哈希进行的。一致性哈希能保证数据在集群中均匀分发，还能在集群扩放时实现数据自动重新分发。

一致性哈希是如何工作的呢？Riak 使用简单的键值对存数数据。键和称为 bucket 的命名空间关联，在 Riak 中处理键和值时，会计算 bucket 和键结合后的哈希值，然后将哈希值映射到一个 160 比特的“整数空间”（integer space）上。整数空间可以设想成一个环，用来决定把数据存储在哪个物理设备上。

怎么决定呢？Riak 把整数空间分成大小相等的分区，分区对应环上特定的取值范围，bucket 和键结合后的哈希值计算出来后就知道落在哪个分区内。每个分区都由一个称为“虚拟节点”（virtual mode，简称 vnode）的进程管理。物理设备会均匀分配每个虚拟节点的任务。假设有一个包含 4 个节点的集群，分成 32 个分区，由 32 个虚拟节点管理。那么每个物理设备就会认领 8 个虚拟节点，负责处理这 8 个虚拟节点中的键，如下图所示。

![A Riak Ring](/images/riak-ring.png)

### 智能复制

Riak 的复制系统可以保证即使某个节点宕机了，仍然可以读写或更新数据。在 Riak 中可以设置复制次数“n”，如果 n 的值为 3（默认值），每个对象会复制三次。当对象的值映射到某个分区上时，Riak 不会就此打住，它会自动复制数据，将其保存在随后的两个分区中。

![A Riak Ring](/images/riak-data-distribution.png)

## 异常处理

即便是在异常情况下，例如硬件失效、网络隔断，Riak 也保有容错、数据集成和可用性。Riak 提供了很多功能来应对这些情况，以及使用过程中可能遇到的其他问题，例如数据的版本冲突。

### 提示移交

提示移交（hinted handoff）用来处理 Riak 节点宕机。如果某个节点宕机了，临近的节点会接管数据存储操作。节点重新运行后，临近的节点会接到通知，交出处理权。提示移交可以保证写数据和更新数据的可用性，而且是自动进行的，把异常处理的过程变得十分简单。

### 版本冲突

在任何有数据复制的系统中都会发生冲突，例如两个客户端同一时间更新同一对象，或者因为迟延不是所有更新都写入了硬件。而且在 Riak 中，数据复制是遵守“最终一致性”原则的，因为数据始终可达，并不是所有的复制操作都能使用最新的数据，因为状态更新是同步的，这样就会导致短暂时间（一般是毫秒级）的不一致性。

那怎么解决冲突呢？发起读请求时，Riak 会查找对象的所有副本，默认情况下，根据对象的“向量时钟”（vector clock）找到数据的最新版本，返回给客户端。向量时钟是副本创建时生成的原数据，每次副本更新时都会得到扩展，以追踪版本。当然，你也可以交由客户端来处理冲突。

### 读取修复

如果读取请求得到的是过时的数据，Riak 会自动更新未同步的副本，以保证一致性。读取修复是 Riak 提供的自修复功能，甚至可以更新因节点物理失效导致的副本丢失。

### 在异常情况下读写数据

在 Riak 中可以为读操作设置一个“r”值，为写操作设置一个“w”值，这两个值表示副本数量，Riak 根据返回副本的数量决定请求是否成功。假设 _n_ 为 3，而且其中一个副本所在的物理节点宕机了，如果 r=2，必须返回两个副本才说明这次读操作是成功的。通过这个功能，即便节点宕机或出现了迟延，Riak 也能保证读操作的可用性。针对写操作的 _w_ 值类似。如果没有设定这两个值，Riak 会取最小值，集群中的大部分节点必须做出响应，详细说明参见 [[CAP Controls]]。

---
title: Using Secondary Indexes
project: riak
version: 1.0.0+
document: tutorials
toc: true
audience: beginner
keywords: [developers, 2i]
moved: {
  '1.4.0-': '/tutorials/querying/Secondary-Indexes'
}
---

When using the [[LevelDB]] or [[Memory]] backend, you have the ability to retrieve objects using external indexes.

## Introduction

Secondary Indexing (2i) in Riak gives developers the ability to tag an object stored in Riak, at write time, with one or more queryable values.

Since the KV data is completely opaque to 2i, the user must tell 2i exactly which attribute(s) to index on and what its index value should be, via key/value metadata. This is different from [[Riak Search|Using Search]], which parses the data and builds indexes based on a schema.

### Features

* Allows two types of secondary attributes: integers and strings (aka binaries)
* Allows querying by exact match or range on one index
* Allows pagination of results {{1.4.0+}}
* Allows streaming of results {{1.4.0+}}
* Query results can be used as input to a [[MapReduce]] query

### When to Use Secondary Indexes

* When you want to find data based on terms other than an object's bucket/key pair. With 2i, indexes can be created by adding metadata to Riak objects.
* When the value being stored is an opaque blob, like a binary file, and you want to index it via added attributes.
* When your use case requires an easy-to-use search mechanism. Secondary indexing does not require a schema (as in Search) and comes with a basic query interface.
* When your use case requires anti-entropy. Since 2i is just metadata on the KV object and the indexes reside on the same node, 2i piggybacks off of read-repair.

### When Not to Use Secondary Indexes

* If your ring size exceeds 512 partitions, 2i can cause performance issues in large clusters.
* When you need more than the exact match and range searches that 2i supports.
* When you want to use composite queries. A query like `last_name=zezeski AND state=MD` would have to be split into two queries and the results merged (or it would need to involve MapReduce).
* When pagination is a requirement. 2i has no support for pagination (all results are always returned). This can be handled to some degree through the use of MapReduce, but adds complexity. {{<1.4.0}}
* When totally ordered result sets are a requirement. Result sets in 2i are only partially ordered. Total ordering must be handled by the client or via MapReduce. {{<1.4.0}}


## Query Interfaces and Examples

{{#1.4.0+}}
Typically, the result set from a 2i query is a list of object keys from the specified bucket that include the index values in question. As we'll see below, when executing range queries in Riak 1.4 or higher, it is possible to retrieve the index values along with the object keys.
{{/1.4.0+}}

In this example, a bucket/key pair of `users`/`john_smith` is used to store user data. The user would like to add a Twitter handle and email address as secondary indexes:

### Inserting the Object with Secondary Indexes

```curl
curl -X POST \
  -H 'x-riak-index-twitter_bin: jsmith123' \
  -H 'x-riak-index-email_bin: jsmith@basho.com' \
  -d '...user data...' \
  http://localhost:8098/buckets/users/keys/john_smith
```

```ruby
bucket = client.bucket 'users'
john_smith_object = Riak::RObject.new(bucket, 'john_smith')
john_smith_object.content_type = '<type>' # type is not specified in this example
john_smith_object.raw_data = '...user data ...'
john_smith_object.indexes['twitter_bin'] = 'jsmith123'
john_smith_object.indexes['email_bin'] = 'jsmith@basho.com'
john_smith_object.store
```

```python
bucket = client.bucket('users')
john_smith_object = RiakObject(bucket, 'john_smith')
john_smith_object.content_type = '<type>' # type is not specified in this example
john_smith_object.data = '...user data...'
john_smith_object.add_index('twitter_bin', 'jsmith123')
john_smith_object.add_index('email_bin', 'jsmith@basho.com')
john_smith_object.store()
```

```java
Bucket usersBucket = client.fetchBucket("users").execute();
String key = "john_smith";
String rawData = "... user data ...";
IRiakObject obj = RiakObjectBuilder
        .newBuilder(usersBucket.getName(), key)
        .withContentType("<type>")
        .withValue(rawData)
        .addIndex("twitter_bin", "jsmith123")
        .addIndex("email_bin", "jsmith@basho.com")
        .build();
usersBucket.store(key, obj).execute();
```

* The object has been stored with a primary bucket/key of `users`/`john_smith`
* The object now has a secondary index called `twitter_bin` with a value of `jsmith123`
* The object now has a secondary index called `email_bin` with a value of `jsmith@basho.com`

### Querying the Object with Secondary Indexes

Query the Twitter handle:

```curl
curl localhost:8098/buckets/users/index/twitter_bin/jsmith123
```

```ruby
bucket = client.bucket 'users'
bucket.get_index 'twitter_bin', 'jsmith123'
```

```python
bucket = client.bucket('users')
bucket.get_index('twitter_bin', 'jsmith123')
```

```java
TODO
```

The response:

```json
{
  "keys": [
    "john_smith"
  ]
}
```


## Examples

To run the following examples, ensure that Riak is running on `localhost` with the HTTP endpoint listing on port `8098` and configured to use an index-capable storage backend.

## Indexing Objects

The following example indexes four different objects. Notice that we're storing both integer and string (aka binary) fields, field names are automatically lowercased, some fields have multiple values, and duplicate fields are automatically de-duplicated:

```curl
curl -v -XPUT \
  -d 'data1' \
  -H "x-riak-index-field1_bin: val1" \
  -H "x-riak-index-field2_int: 1001" \
  http://127.0.0.1:8098/buckets/mybucket/keys/mykey1

curl -v -XPUT \
  -d 'data2' \
  -H "x-riak-index-Field1_bin: val2" \
  -H "x-riak-index-Field2_int: 1002" \
 http://127.0.0.1:8098/buckets/mybucket/keys/mykey2

curl -v -XPUT \
  -d 'data3' \
  -H "X-RIAK-INDEX-FIELD1_BIN: val3" \
  -H "X-RIAK-INDEX-FIELD2_INT: 1003" \
  http://127.0.0.1:8098/buckets/mybucket/keys/mykey3

curl -v -XPUT \
  -d 'data4' \
  -H "x-riak-index-field1_bin: val4, val4, val4a, val4b" \
  -H "x-riak-index-field2_int: 1004, 1004, 1005, 1006" \
  -H "x-riak-index-field2_int: 1004" \
  -H "x-riak-index-field2_int: 1004" \
  -H "x-riak-index-field2_int: 1004" \
  -H "x-riak-index-field2_int: 1007" \
  http://127.0.0.1:8098/buckets/mybucket/keys/mykey4
```

```ruby
bucket = client.bucket 'mybucket'

mykey1 = Riak::RObject.new(bucket, 'mykey1')
mykey1.content_type = 'text/plain'
mykey1.raw_data = 'data1'
mykey1.indexes['field1_bin'] = 'val1'
mykey1.indexes['field2_int'] = 1001
mykey1.store

mykey2 = Riak::RObject.new(bucket, 'mykey2')
mykey1.content_type = 'text/plain'
mykey2.raw_data = 'data2'
mykey2.indexes['Field1_bin'] = 'val2'
mykey2.indexes['Field2_int'] = 1002
mykey2.store

mykey3 = Riak::RObject.new(bucket, 'mykey3')
mykey1.content_type = 'text/plain'
mykey3.raw_data = 'data3'
mykey3.indexes['FIELD1_BIN'] = 'val3'
mykey3.indexes['FIELD2_INT'] = 1003
mykey3.store

mykey4 = Riak::RObject.new(bucket, 'mykey4')
mykey1.content_type = 'text/plain'
mykey4.raw_data = 'data4'
mykey4.indexes['field1_bin'] = 'val4', 'val4', 'val4a', 'val4b'
mykey4.indexes['field2_int'] = 1004, 1004, 1005, 1006
mykey4.indexes['field2_int'] = 1004
mykey4.indexes['field2_int'] = 1004
mykey4.indexes['field2_int'] = 1004
mykey4.indexes['field2_int'] = 1007
mykey4.store
```

```python
bucket = client.bucket('mybucket')

mykey1 = RiakObject(bucket, 'mykey1')
mykey1.content_type = 'text/plain'
mykey1.data = 'data1'
mykey1.add_index('field1_bin', 'val1')
mykey1.add_index('field2_int', 1001)
mykey1.store()

mykey2 = RiakObject(bucket, 'mykey2')
mykey1.content_type = 'text/plain'
mykey2.data = 'data2'
mykey2.add_index('Field1_bin', 'val2')
mykey2.add_index('Field2_int', 1002)
mykey2.store()

mykey3 = RiakObject(bucket, 'mykey3')
mykey1.content_type = 'text/plain'
mykey3.data = 'data3'
mykey3.add_index('FIELD1_BIN', 'val3')
mykey3.add_index('FIELD2_INT', 1003)
mykey3.store()

mykey4 = RiakObject(bucket, 'mykey4')
mykey1.content_type = 'text/plain'
mykey4.data = 'data4'
for val in ['val4', 'val4', 'val4a', 'val4b']:
    mykey4.add_index('field1_bin', val)
for i in [1004, 1004, 1005, 1006]:
    mykey4.add_index('field2_int', i)
mykey4.add_index('field2_int', 1004)
mykey4.add_index('field2_int', 1004)
mykey4.add_index('field2_int', 1004)
mykey4.add_index('field2_int', 1007)
mykey4.store()
```

```java
String key1 = "mykey1";
IRiakObject obj1 = RiakObjectBuilder
        .newBuilder(usersBucket.getName(), key1)
        .withContentType("text/plain").withValue("data1")
        .addIndex("field1_bin", "val1").addIndex("field2_int", 1001)
        .build();
usersBucket.store(key1, obj1).execute();

String key2 = "mykey2";
IRiakObject obj2 = RiakObjectBuilder
        .newBuilder(usersBucket.getName(), key2)
        .withContentType("text/plain").withValue("data2")
        .addIndex("Field1_bin", "val2").addIndex("Field2_int", 1002)
        .build();
usersBucket.store(key2, obj2).execute();

String key3 = "mykey3";
IRiakObject obj3 = RiakObjectBuilder
        .newBuilder(usersBucket.getName(), key3)
        .withContentType("text/plain").withValue("data3")
        .addIndex("FIELD1_BIN", "val3").addIndex("FIELD2_INT", 1003)
        .build();
usersBucket.store(key3, obj3).execute();
```

The following examples demonstrate what happens when an index field is specified with an invalid field name or type. The system responds with `400 Bad Request` and a description of the error.

Invalid field name:

```curl
curl -XPUT \
-d 'data1' \
-H "x-riak-index-field2_foo: 1001" \
http://127.0.0.1:8098/buckets/mybucket/keys/mykey

# Response
Unknown field type for field: 'field2_foo'.
```

```ruby
bucket = client.bucket 'mybucket'
mykey = Riak::RObject.new(bucket, 'mykey')
mykey.content_type = 'text/plain'
mykey.raw_data = 'data1'
mykey.indexes['field2_foo'] = 1001

# Response
NoMethodError: undefined method 'map' for 1001:Fixnum
```

```python
bucket = client.bucket('mybucket')
mykey = RiakObject(bucket, 'mykey')
mykey.content_type = 'text/plain'
mykey.data = 'data1'
mykey.add_index('field2_foo', 1001)

# Response
riak.RiakError: "Riak 2i fields must end with either '_bin' or '_int'."
```

```java
Bucket myBucket = client.fetchBucket("mybucket").execute();
String key = "mykey";
IRiakObject obj = RiakObjectBuilder
        .newBuilder(mybucket.getName(), key)
        .withContentType("text/plain")
        .withValue("data1")
        .addIndex("field2_foo", 1001)
        .build();
myBucket.store(key, obj).execute();

// In this case, the Java client will create an index called field2_foo_int, on the basis of a value of 1001 being passed in.
```

Incorrect data type:

```curl
curl -XPUT \
-d 'data1' \
-H "x-riak-index-field2_int: bar" \
http://127.0.0.1:8098/buckets/mybucket/keys/mykey

# Response
Could not parse field 'field2_int', value 'bar'.
```

```ruby
bucket = client.bucket 'mybucket'
mykey = Riak::RObject.new(bucket, 'mykey')
mykey.content_type = 'text/plain'
mykey.raw_data = 'data1'
mykey.indexes['field2_int'] = 'bar'
mykey.store

# Response will be something like the following:
NoMethodError: undefined method 'map' for "bar":String
```

```python
bucket = client.bucket('mybucket')
mykey = RiakObject(bucket, 'mykey')
mykey.content_type = 'text/plain'
mykey.data = 'data1'
mykey.add_index('field2_int', 'bar')
mykey.store()

# Response will be something like the following:
AttributeError: 'RiakBucket' object has no attribute 'put'
```

```java
Bucket myBucket = client.fetchBucket("mybucket").execute();
String key = "mykey";
IRiakObject obj = RiakObjectBuilder
      .newBuilder(myBucket.getName(), key)
      .withContentType("text/plain")
      .withValue("data1")
      .addIndex("field2_int", "bar")
      .build();
myBucket.store(key, obj).execute();

// In this case, the Java client will create an index called field2_int_bin, on the basis of a value of the String "bar" being passed in.
```

## Querying

### Exact Match

The following examples use the HTTP interface to perform an exact match index query:

Query a binary index

```curl
curl http://localhost:8098/buckets/mybucket/index/field1_bin/val1
```

```ruby
bucket = client.bucket 'mybucket'
bucket.get_index 'field1_bin', 'val1'
```

```python
bucket = client.bucket('mybucket')
bucket.get_index('field1_bin', 'val1')
```

```java
TODO
```

Query an integer index

```curl
curl http://localhost:8098/buckets/mybucket/index/field2_int/1001
```

```ruby
bucket = client.bucket 'mybucket'
bucket.get_index 'field2_int', 1001
```

```python
bucket = client.bucket('mybucket')
bucket.get_index('field2_int', 1001)
```

```java
TODO
```

The following example performs an exact match query and pipes the results into a MapReduce job:

```curl
curl -X POST \
  -H "content-type: application/json" \
  -d @- \
  http://localhost:8098/mapred \
<<EOF
{
  "inputs": {
    "bucket": "mybucket",
    "index": "field1_bin",
    "key":"val3"
  },
  "query": [
    {
      "reduce": {
        "language":"erlang",
        "module": "riak_kv_mapreduce",
        "function": "reduce_identity",
        "keep": true
      }
    }
  ]
}
EOF
```

```ruby
results = Riak::MapReduce.new(client).
                add('mybucket', 'field1_bin').
                link(bucket: 'mybucket').
                map("Riak.riak_kv_mapreduce", keep: true).run
```

```python
results = RiakMapReduce(client).add('mybucket', 'field1_bin').link()
```

### Range

The following examples perform a range query:

Query a binary index...

```curl
curl http://localhost:8098/buckets/mybucket/index/field1_bin/val2/val4
```

```ruby
bucket = client.bucket 'mybucket'
bucket.get_index 'field1_bin', 'val2'..'val4'
```

```python
bucket = client.bucket('mybucket')
bucket.get_index('field1_bin', 'val2', 'val4')
```

Query an integer index...

```curl
curl http://localhost:8098/buckets/mybucket/index/field2_int/1002/1004
```

```ruby
bucket = client.bucket 'mybucket'
bucket.get_index 'field2_int', 1002..1004
```

```python
bucket = client.bucket('mybucket')
bucket.get_index('field2_int', 1002, 1004)
```

The following example performs a range query and pipes the results into a MapReduce job:

```curl
curl -X POST \
  -H "content-type: application/json" \
  -d @- \
  http://localhost:8098/mapred \
<<EOF
{
  "inputs":{
    "bucket": "mybucket",
    "index": "field1_bin",
    "start": "val2",
    "end": "val4"
  },
  "query": [
    {
      "reduce": {
        "language": "erlang",
        "module": "riak_kv_mapreduce",
        "function": "reduce_identity",
        "keep": true
      }
    }
  ]
}
EOF
```

{{#1.4.0+}}
#### Range with terms

When performing a range query, it is possible to retrieve the matched index values alongside the Riak keys using `return_terms=true`. An example from a small sampling of Twitter data with indexed hash tags:

```curl
curl http://localhost:8098/buckets/tweets/index/hashtags_bin/rock/rocl?return_terms=true

# Response
{"results":[{"rock":"349224101224787968"},{"rocks":"349223639880699905"}]}
```

```ruby
bucket = client.bucket 'tweets'
bucket.get_index 'hashtags_bin', 'rock'..'rocl', return_terms: true
```

```python
bucket = client.bucket('tweets')
bucket.get_index('hashtags_bin', 'rock', 'rocl', return_terms=True)
```
{{/1.4.0+}}

{{#1.4.0+}}
### Pagination

When asking for large result sets, it is often desirable to ask the servers to return chunks of results instead of a firehose. As of Riak 1.4, you can do so using `max_results=<n>`, where `n` is the number of results you'd like to receive.

Assuming more keys are available, a `continuation` value will be included in the results to allow the client to request the next page.

Here is an example of a range query with both `return_terms` and pagination against the same Twitter data set.  Results are fed into python for easier reading.

```bash
curl http://localhost:8098/buckets/tweets/index/hashtags_bin/ri/ru?max_results=5&return_terms=true | python -mjson.tool
```

```ruby
bucket = client.bucket 'tweets'
bucket.get_index 'hashtags_bin', 'ri'..'ru', max_results: 5, return_terms: true
```

```python
bucket = client.bucket('tweets')
bucket.get_index('hashtags_bin', 'ri', 'ru', max_results=5, return_terms=True)
```

Response:

```json
{
  "continuation": "g2gCbQAAAAdyaXBqYWtlbQAAABIzNDkyMjA2ODcwNTcxMjk0NzM=",
  "results": [
    { "rice": "349222574510710785" },
    { "rickross": "349222868095217664" },
    { "ridelife": "349221819552763905" },
    { "ripjake": "349220649341952001" },
    { "ripjake": "349220687057129473" }
  ]
}
```

Take the continuation value from the previous result set and feed it back into the query.

```curl
curl 'http://localhost:8098/buckets/tweets/index/hashtags_bin/ri/ru?continuation=g2gCbQAAAAdyaXBqYWtlbQAAABIzNDkyMjA2ODcwNTcxMjk0NzM=&max_results=5&return_terms=true' | python -mjson.tool
{
    "continuation": "g2gCbQAAAAlyb2Jhc2VyaWFtAAAAEjM0OTIyMzcwMjc2NTkxMjA2NQ==",
    "results": [
        {
            "ripjake": "349221198774808579"
        },
        {
            "ripped": "349224017347100672"
        },
        {
            "roadtrip": "349221207155032066"
        },
        {
            "roastietime": "349221370724491265"
        },
        {
            "robaseria": "349223702765912065"
        }
    ]
}
```
{{/1.4.0+}}

{{#1.4.0+}}
### Streaming
It is possible to stream results using `stream=true`.

```curl
curl http://localhost:8098/buckets/mybucket/index/myindex_bin/foo?stream=true
```

```ruby
bucket = client.bucket 'mybucket'
keys = Riak::SecondaryIndex.new bucket, 'myindex_bin', 'foo', stream: true
keys.each do |k|
  # do something with each key
end
```

```python
bucket = client.bucket('mybucket')
for keys in bucket.stream_index('myindex_bin', 'foo'):
  # do something with each key
```

Streaming can also be combined with `pagination` and `return_terms`.

{{/1.4.0+}}

{{#1.4.0+}}
### Sorting
As of Riak 1.4, the result set is sorted on index values (when executing range queries) and object keys. See the pagination example above: hash tags (2i keys) are returned in ascending order, and the object keys (Twitter IDs) for the messages which contain the `ripjake` hash tag are also returned in ascending order.

{{/1.4.0+}}

### Retrieve all Bucket Keys via `$bucket` Index

The following example retrieves the keys for all objects stored in the bucket `mybucket` using an exact match on the special `$bucket` index.

```curl
curl http://localhost:8098/buckets/mybucket/index/\$bucket/_
```

```ruby

```

```python

```

### Count Bucket Objects via $bucket Index

The following example performs a secondary index lookup on the $bucket index like in the previous example and pipes this into a MapReduce that counts the number of records in the 'mybucket' bucket. In order to improve efficiency, the batch size has been increased from the default size of 20.

```curl
curl -XPOST http://localhost:8098/mapred
  -H 'Content-Type: application/json'
  -d '{"inputs":{
        "bucket":"mybucket",
        "index":"$bucket",
        "key":"mybucket"
      },
      "query": [{ "reduce": {
                              "language":"erlang",
                              "module":"riak_kv_mapreduce",
                              "function":"reduce_count_inputs",
                              "arg": { 
                                "reduce_phase_batch_size":1000
                              }
                            }
               }]
       }'
EOF
```
